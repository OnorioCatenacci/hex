defmodule Mix.Tasks.Hex.Docs do
  use Mix.Task
  alias Mix.Hex.Utils

  @shortdoc "Publishes docs for package"

  @moduledoc """
  Publishes documentation for the current project and version.

  The documentation will be accessible at `https://hexdocs.pm/my_package/1.0.0`,
  `https://hexdocs.pm/my_package` will always redirect to the latest published
  version.

  Documentation will be generated by running the `mix docs` task. `ex_doc`
  provides this task by default, but any library can be used. Or an alias can be
  used to extend the documentation generation. The expected result of the task
  is the generated documentation located in the `docs/` directory with an
  `index.html` file.

  ## Command line options

    * `--revert VERSION` - Revert given version
    * `open --package PACKAGE` - Opens the docs for specified package in the default web browser. Defaults to current package.
    * `fetch --package PACKAGE  --version VERSION` - Gets a copy of the docs for the specified package and version to the local machine. Defaults to current package and version.
  """

  @switches [revert: :string, progress: :boolean, package: :string, version: :string]

  def run(args) do
    Hex.start
      
    Hex.Utils.ensure_registry(fetch: false)

    {opts, args, _} = OptionParser.parse(args, switches: @switches)
    auth = Utils.auth_info()
    Mix.Project.get!
    config  = Mix.Project.config
    name    = config[:package][:name] || config[:app]
    version = config[:version]

    package_name = if (opts[:package]), do: opts[:package], else: name
    package_version  = if (opts[:version]), do: opts[:version], else: version
    if revert = opts[:revert] do
      revert(name, revert, auth)
    else
      case args do
        ["open"] ->
          open_docs(package_name)
        ["fetch"] ->
          fetch_hex_docs(package_name, package_version)
        _ -> Mix.raise "Invalid arguments, expected one of:\n" <>
            "mix hex.docs open \n" <>
            "mix.hex.docs fetch [Package] [Version] \n"
       
     
#      try do
#        docs_args = ["--canonical", Hex.Utils.hexdocs_url(name)|args]
#        Mix.Task.run("docs", docs_args)
#      rescue ex in [Mix.NoTaskError] ->
#        stacktrace = System.stacktrace
#        Mix.shell.error ~s(The "docs" task is unavailable, add {:ex_doc, ">= x.y.z", only: [:dev]}) <>
#                        ~s( to your dependencies or if ex_doc was already added make sure you run) <>
#                        ~s( the task in the same environment it is configured to)
#        reraise ex, stacktrace
#      end

#     directory = docs_dir()

#     unless File.exists?("#{directory}/index.html") do
#       Mix.raise "File not found: #{directory}/index.html"
#     end

#     progress? = Keyword.get(opts, :progress, true)
#     tarball = build_tarball(name, version, directory)
#     send_tarball(name, version, tarball, auth, progress?)
      end
    end
  end
  

  defp open_docs(name) do
    doc_index = "#{Utils.get_docs_directory(name)}/index.html"
    unless File.exists?(doc_index) do
      Mix.raise "Documentation file not found: #{doc_index}"
    end
    start_browser_command =
      case (:os.type()) do
        {:win32,_} -> "start"
        {:unix,_} -> "xdg-open"
      end
  
    System.cmd(start_browser_command, [doc_index])
  end
  
  defp fetch_hex_docs(name, version) do
    doc_dir = Utils.get_docs_directory(name)
    Hex.Shell.info("doc_dir = #{doc_dir}")
    unless File.exists?(doc_dir), do: :ok = File.mkdir_p(doc_dir)

    doc_file_glob= "#{Hex.Utils.hexdocs_url(name)}/*.html"
    Hex.Shell.info("doc_file_glob is #{doc_file_glob}")
    Hex.Shell.info("Utils.hexdocs_url(name, version) returns #{Hex.Utils.hexdocs_url(name)}")
    case (Hex.SCM.request(doc_file_glob,"")) do
          -> {:ok, resp} 
            tarfile = "#{doc_index}/*.html"
            File.write!(tarfile, resp)
#            :erl_tar.extract(tarfile,[:compressed])
          
          -> {:error, message} 
            Mix.raise("Unable to fetch documentation. Message returned is #{message}")
      end    
  end
    

  defp build_tarball(name, version, directory) do
    tarball = "#{name}-#{version}-docs.tar.gz"
    files = files(directory)
    :ok = :erl_tar.create(tarball, files, [:compressed])
    data = File.read!(tarball)

    File.rm!(tarball)
    data
  end

  defp send_tarball(name, version, tarball, auth, progress?) do
    progress =
      if progress? do
        Utils.progress(byte_size(tarball))
      else
        Utils.progress(nil)
      end

    case Hex.API.ReleaseDocs.new(name, version, tarball, auth, progress) do
      {code, _, _} when code in 200..299 ->
        Hex.Shell.info ""
        Hex.Shell.info "Published docs for #{name} #{version}"
        # TODO: Only print this URL if we use the default API URL
        Hex.Shell.info "Hosted at #{Hex.Utils.hexdocs_url(name, version)}"
      {code, body, _} ->
        Hex.Shell.info ""
        Hex.Shell.error "Pushing docs for #{name} v#{version} failed"
        Hex.Utils.print_error_result(code, body)
    end
  end

  defp revert(name, version, auth) do
    version = Utils.clean_version(version)

    case Hex.API.ReleaseDocs.delete(name, version, auth) do
      {code, _, _} when code in 200..299 ->
        Hex.Shell.info "Reverted docs for #{name} #{version}"
      {code, body, _} ->
        Hex.Shell.error "Reverting docs for #{name} #{version} failed"
        Hex.Utils.print_error_result(code, body)
    end
  end

  defp files(directory) do
    "#{directory}/**"
    |> Path.wildcard
    |> Enum.filter(&File.regular?/1)
    |> Enum.map(&{relative_path(&1, directory), File.read!(&1)})
  end

  defp relative_path(file, dir) do
    Path.relative_to(file, dir)
    |> String.to_char_list
  end

  defp docs_dir do
    cond do
      File.exists?("doc") ->
        "doc"
      File.exists?("docs") ->
        "docs"
      true ->
        Mix.raise("Documentation could not be found. Please ensure documentation is in the doc/ or docs/ directory")
    end
  end
end
